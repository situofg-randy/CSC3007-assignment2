{"ast":null,"code":"import { dispatch } from \"d3-dispatch\";\nimport { timer } from \"d3-timer\";\nimport lcg from \"./lcg.js\";\nexport function x(d) {\n  return d.x;\n}\nexport function y(d) {\n  return d.y;\n}\nvar initialRadius = 10,\n    initialAngle = Math.PI * (3 - Math.sqrt(5));\nexport default function (_nodes) {\n  var simulation,\n      _alpha = 1,\n      _alphaMin = 0.001,\n      _alphaDecay = 1 - Math.pow(_alphaMin, 1 / 300),\n      _alphaTarget = 0,\n      _velocityDecay = 0.6,\n      forces = new Map(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\"),\n      random = lcg();\n\n  if (_nodes == null) _nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n\n    if (_alpha < _alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick(iterations) {\n    var i,\n        n = _nodes.length,\n        node;\n    if (iterations === undefined) iterations = 1;\n\n    for (var k = 0; k < iterations; ++k) {\n      _alpha += (_alphaTarget - _alpha) * _alphaDecay;\n      forces.forEach(function (force) {\n        force(_alpha);\n      });\n\n      for (i = 0; i < n; ++i) {\n        node = _nodes[i];\n        if (node.fx == null) node.x += node.vx *= _velocityDecay;else node.x = node.fx, node.vx = 0;\n        if (node.fy == null) node.y += node.vy *= _velocityDecay;else node.y = node.fy, node.vy = 0;\n      }\n    }\n\n    return simulation;\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = _nodes.length, node; i < n; ++i) {\n      node = _nodes[i], node.index = i;\n      if (node.fx != null) node.x = node.fx;\n      if (node.fy != null) node.y = node.fy;\n\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius = initialRadius * Math.sqrt(0.5 + i),\n            angle = i * initialAngle;\n        node.x = radius * Math.cos(angle);\n        node.y = radius * Math.sin(angle);\n      }\n\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(_nodes, random);\n    return force;\n  }\n\n  initializeNodes();\n  return simulation = {\n    tick: tick,\n    restart: function restart() {\n      return stepper.restart(step), simulation;\n    },\n    stop: function stop() {\n      return stepper.stop(), simulation;\n    },\n    nodes: function nodes(_) {\n      return arguments.length ? (_nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : _nodes;\n    },\n    alpha: function alpha(_) {\n      return arguments.length ? (_alpha = +_, simulation) : _alpha;\n    },\n    alphaMin: function alphaMin(_) {\n      return arguments.length ? (_alphaMin = +_, simulation) : _alphaMin;\n    },\n    alphaDecay: function alphaDecay(_) {\n      return arguments.length ? (_alphaDecay = +_, simulation) : +_alphaDecay;\n    },\n    alphaTarget: function alphaTarget(_) {\n      return arguments.length ? (_alphaTarget = +_, simulation) : _alphaTarget;\n    },\n    velocityDecay: function velocityDecay(_) {\n      return arguments.length ? (_velocityDecay = 1 - _, simulation) : 1 - _velocityDecay;\n    },\n    randomSource: function randomSource(_) {\n      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;\n    },\n    force: function force(name, _) {\n      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);\n    },\n    find: function find(x, y, radius) {\n      var i = 0,\n          n = _nodes.length,\n          dx,\n          dy,\n          d2,\n          node,\n          closest;\n      if (radius == null) radius = Infinity;else radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = _nodes[i];\n        dx = x - node.x;\n        dy = y - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n    on: function on(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}","map":{"version":3,"names":["dispatch","timer","lcg","x","d","y","initialRadius","initialAngle","Math","PI","sqrt","nodes","simulation","alpha","alphaMin","alphaDecay","pow","alphaTarget","velocityDecay","forces","Map","stepper","step","event","random","tick","call","stop","iterations","i","n","length","node","undefined","k","forEach","force","fx","vx","fy","vy","initializeNodes","index","isNaN","radius","angle","cos","sin","initializeForce","initialize","restart","_","arguments","randomSource","name","delete","set","get","find","dx","dy","d2","closest","Infinity","on"],"sources":["/Users/angrandy/node_modules/d3-force/src/simulation.js"],"sourcesContent":["import {dispatch} from \"d3-dispatch\";\nimport {timer} from \"d3-timer\";\nimport lcg from \"./lcg.js\";\n\nexport function x(d) {\n  return d.x;\n}\n\nexport function y(d) {\n  return d.y;\n}\n\nvar initialRadius = 10,\n    initialAngle = Math.PI * (3 - Math.sqrt(5));\n\nexport default function(nodes) {\n  var simulation,\n      alpha = 1,\n      alphaMin = 0.001,\n      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n      alphaTarget = 0,\n      velocityDecay = 0.6,\n      forces = new Map(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\"),\n      random = lcg();\n\n  if (nodes == null) nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick(iterations) {\n    var i, n = nodes.length, node;\n\n    if (iterations === undefined) iterations = 1;\n\n    for (var k = 0; k < iterations; ++k) {\n      alpha += (alphaTarget - alpha) * alphaDecay;\n\n      forces.forEach(function(force) {\n        force(alpha);\n      });\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        if (node.fx == null) node.x += node.vx *= velocityDecay;\n        else node.x = node.fx, node.vx = 0;\n        if (node.fy == null) node.y += node.vy *= velocityDecay;\n        else node.y = node.fy, node.vy = 0;\n      }\n    }\n\n    return simulation;\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (node.fx != null) node.x = node.fx;\n      if (node.fy != null) node.y = node.fy;\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;\n        node.x = radius * Math.cos(angle);\n        node.y = radius * Math.sin(angle);\n      }\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(nodes, random);\n    return force;\n  }\n\n  initializeNodes();\n\n  return simulation = {\n    tick: tick,\n\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;\n    },\n\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n\n    randomSource: function(_) {\n      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;\n    },\n\n    force: function(name, _) {\n      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n    },\n\n    find: function(x, y, radius) {\n      var i = 0,\n          n = nodes.length,\n          dx,\n          dy,\n          d2,\n          node,\n          closest;\n\n      if (radius == null) radius = Infinity;\n      else radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x - node.x;\n        dy = y - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}